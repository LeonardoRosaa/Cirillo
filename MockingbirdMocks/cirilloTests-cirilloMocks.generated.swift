//
//  cirilloTests-cirilloMocks.generated.swift
//  cirillo
//
//  Generated by Mockingbird v0.20.0.
//  DO NOT EDIT
//

@testable import Mockingbird
@testable import cirillo
import Combine
import Foundation
import Swift
import SwiftUI
import Swinject
import UserNotifications

private let mkbGenericStaticMockContext = Mockingbird.GenericStaticMockContext()

// MARK: - Mocked NotificationGateway
public final class NotificationGatewayMock: cirillo.NotificationGateway, Mockingbird.Mock {
  typealias MockingbirdSupertype = cirillo.NotificationGateway
  public static let mockingbirdContext = Mockingbird.Context()
  public let mockingbirdContext = Mockingbird.Context(["generator_version": "0.20.0", "module_name": "cirillo"])

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    self.mockingbirdContext.sourceLocation = sourceLocation
    NotificationGatewayMock.mockingbirdContext.sourceLocation = sourceLocation
  }

  // MARK: Mocked `requestPermission`(`completionHandler`: @escaping (Bool, Error?) -> Void)
  public func `requestPermission`(`completionHandler`: @escaping (Bool, Error?) -> Void) -> Void {
    return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`requestPermission`(`completionHandler`: @escaping (Bool, Error?) -> Void) -> Void", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`completionHandler`)], returnType: Swift.ObjectIdentifier((Void).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? (@escaping (Bool, Error?) -> Void) -> Void { return mkbImpl(`completionHandler`) }
      if let mkbImpl = mkbImpl as? () -> Void { return mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          break
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: Void = mkbObject.`requestPermission`(completionHandler: `completionHandler`)
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Void).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `requestPermission`(`completionHandler`: @autoclosure () -> (Bool, Error?) -> Void) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (@escaping (Bool, Error?) -> Void) -> Void, Void> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (@escaping (Bool, Error?) -> Void) -> Void, Void>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`requestPermission`(`completionHandler`: @escaping (Bool, Error?) -> Void) -> Void", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`completionHandler`)], returnType: Swift.ObjectIdentifier((Void).self)))
  }

  // MARK: Mocked `push`(`id`: String, `title`: String, `description`: String)
  public func `push`(`id`: String, `title`: String, `description`: String) -> Void {
    return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`push`(`id`: String, `title`: String, `description`: String) -> Void", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`id`), Mockingbird.ArgumentMatcher(`title`), Mockingbird.ArgumentMatcher(`description`)], returnType: Swift.ObjectIdentifier((Void).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? (String, String, String) -> Void { return mkbImpl(`id`, `title`, `description`) }
      if let mkbImpl = mkbImpl as? () -> Void { return mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          break
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: Void = mkbObject.`push`(id: `id`, title: `title`, description: `description`)
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Void).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `push`(`id`: @autoclosure () -> String, `title`: @autoclosure () -> String, `description`: @autoclosure () -> String) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (String, String, String) -> Void, Void> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (String, String, String) -> Void, Void>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`push`(`id`: String, `title`: String, `description`: String) -> Void", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`id`), Mockingbird.resolve(`title`), Mockingbird.resolve(`description`)], returnType: Swift.ObjectIdentifier((Void).self)))
  }
}

/// Returns a concrete mock of `NotificationGateway`.
public func mock(_ type: cirillo.NotificationGateway.Protocol, file: StaticString = #file, line: UInt = #line) -> NotificationGatewayMock {
  return NotificationGatewayMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked NotificationService
public final class NotificationServiceMock: cirillo.NotificationService, Mockingbird.Mock {
  typealias MockingbirdSupertype = cirillo.NotificationService
  public static let mockingbirdContext = Mockingbird.Context()
  public let mockingbirdContext = Mockingbird.Context(["generator_version": "0.20.0", "module_name": "cirillo"])

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    self.mockingbirdContext.sourceLocation = sourceLocation
    NotificationServiceMock.mockingbirdContext.sourceLocation = sourceLocation
  }

  // MARK: Mocked `requestPermission`()
  public func `requestPermission`() -> Void {
    return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`requestPermission`() -> Void", selectorType: Mockingbird.SelectorType.method, arguments: [], returnType: Swift.ObjectIdentifier((Void).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? () -> Void { return mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          break
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: Void = mkbObject.`requestPermission`()
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Void).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `requestPermission`() -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> Void, Void> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> Void, Void>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`requestPermission`() -> Void", selectorType: Mockingbird.SelectorType.method, arguments: [], returnType: Swift.ObjectIdentifier((Void).self)))
  }

  // MARK: Mocked `push`(`title`: String, `description`: String)
  public func `push`(`title`: String, `description`: String) -> Void {
    return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`push`(`title`: String, `description`: String) -> Void", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`title`), Mockingbird.ArgumentMatcher(`description`)], returnType: Swift.ObjectIdentifier((Void).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? (String, String) -> Void { return mkbImpl(`title`, `description`) }
      if let mkbImpl = mkbImpl as? () -> Void { return mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          break
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: Void = mkbObject.`push`(title: `title`, description: `description`)
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Void).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `push`(`title`: @autoclosure () -> String, `description`: @autoclosure () -> String) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (String, String) -> Void, Void> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (String, String) -> Void, Void>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`push`(`title`: String, `description`: String) -> Void", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`title`), Mockingbird.resolve(`description`)], returnType: Swift.ObjectIdentifier((Void).self)))
  }
}

/// Returns a concrete mock of `NotificationService`.
public func mock(_ type: cirillo.NotificationService.Protocol, file: StaticString = #file, line: UInt = #line) -> NotificationServiceMock {
  return NotificationServiceMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}
